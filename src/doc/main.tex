\documentclass{report}
% \usepackage{hyperref}
\usepackage{fontspec}
\setmainfont{CMU Serif}
\setmonofont{FiraCode-Regular}

\usepackage[style=alphabetic,natbib=true]{biblatex}
\addbibresource{ref.bib}

\usepackage{amsmath}
\usepackage{amsthm}
\usepackage{amsfonts}
\theoremstyle{definition}
\newtheorem{example}{Example}

\theoremstyle{plain}
\newtheorem{theorem}{Theorem}

\usepackage{minted}

\title{A formalisation of transcendence of $e$}
\author{Jujian Zhang}

\begin{document}
\maketitle

% Abstract
\abstract{}
The objective of this report is to present formalisations of some basic theorems from transcendental number theory with {\tt Lean} and {\tt mathlib} in the hope that it will serve as a motivation for mathematicians to be more curious about interactive theorem proving. The following theorems are formalised:
\begin{enumerate}
  \item the set of algebraic numbers is countable, hence transcendental number exists:
  \begin{minted}[mathescape,linenos,numbersep=5pt,frame=lines,framesep=2mm,fontsize=\footnotesize]{Lean}
theorem algebraic_set_countable : set.countable algebraic_set
theorem transcendental_number_exists : ∃ x : ℝ, transcendental x
  \end{minted}
  \item all Liouville's numbers are transcendental:
  \begin{minted}[mathescape,linenos,numbersep=5pt,frame=lines,framesep=2mm,fontsize=\footnotesize]{Lean}
theorem liouville_numbers_transcendental : 
  ∀ x : ℝ, liouville_number x -> transcendental x
  \end{minted}
  \item $\alpha := \sum_{i=0}^\infty\frac1{10^{i!}}$ is a Liouville's number hence $\alpha$ is transcendental.
  \begin{minted}[mathescape,linenos,numbersep=5pt,frame=lines,framesep=2mm,fontsize=\footnotesize]{Lean}
theorem liouville_α : liouville_number α
theorem transcendental_α : transcendental α := 
  liouville_numbers_transcendental α liouville_α

  \end{minted} 

  \item $e$ is transcendental:
  \begin{minted}[mathescape,linenos,numbersep=5pt,frame=lines,framesep=2mm,fontsize=\footnotesize]{Lean}
theorem e_transcendental : transcendental e
  \end{minted} 
\end{enumerate}

\section*{Disclaimer}

The plan is to a self-contained report so that after chapter \ref{intro:lean} any reader even without prior exposure to interactive theorem proving will be able to understand \ref{fmlsn} where the details of formalisations and proofs reside. This should be relatively straightforward since the author is a {\tt Lean}-dilettantes at best with only a partial picture of the full language. For the same reason, much of the code is perhaps not idiomatic or even plainly bad, thus it is not advisable to use this as a tutorial.

\tableofcontents

\chapter{Overview}
\section{Interactive theorem proving}
Around 1920s, the German mathematician David Hilbert put forward the Hilbert programme to seek:
\begin{enumerate}
  \item an axiomatic foundation of mathematics;
  \item a proof of consistency of the said foundation;
  \item Entscheidungsproblem: an algorithm to determine if any proposition is universally valid given a set of axioms.
\end{enumerate}
The first two aims were later proved to be impossible by G\"odel and the celebrated incompleteness theorems. Via the completeness of first order logic, the Entscheidungsproblem can also be interpreted as an algorithm for producing proofs using deduction rules. Even without a panacea approach for mathematics, computer still bears advantages against a carbon-based mathematician. Perhaps the most manifested advantage is the accuracy of a computer to execute its command and to recall its memories. Thus came the idea of {\bf interactive theorem proving} --- instead of hoping a computer algorithm to spit out some unfathomable proofs, assuming computers are given the ability to check correctness of proofs, human-comprehensible proofs can be verified by machines and thus guaranteed to be free of errors. With a collective effort, all theorems verified this way can be collected in an error-free library such that all mathematicians can utilise to prove further theorems which can then be added to the collection, ad infinitum \cite{boyer1994qed}. Curry-Howard isomorphism provided the crucial relationship between mathematical proofs and computer programmes, more specifically relationship between propositions and types, to make such project feasible \cite{kennedy2011set}. The idea will be explained in section \ref{intro:lean} along with {\tt Lean}. 

The proof of ``Kepler's conjecture\footnote{the most efficient way to pack spheres should be hexagonally}'' will serve as an illustrative example of utility of interactive theorem proving. As early as 1998, Thomas Hales had claimed a proof \cite{hales1998kepler,harrison2014history}, however the proof is controversial in the sense that mathematician even with great effort could not guarantee its correctness. A collaborative project using {\tt Isabelle}\footnote{a theorem prover relies extensively on dependent type theory and Curry-Howard correspondence.} and {\tt HOL Light}\footnote{ibid.} verified the proof around 2014 and hence settled the controversy in 2017 \cite{hales2017formal}. There is also Georges Gonthier with his teams using {\tt Coq}\footnote{ibid.} who formalised the four colour theorem and Feit-Thompson theorem where the latter is a step to the classification of simple groups \cite{gonthier2008formal, gonthier2013machine}. Using {\tt Lean}\footnote{ibid.}, \Citeauthor{buzzard2020formalising} were able to formalise modern notion of perfectoid spaces \cite{buzzard2020formalising}.

\section{History of transcendental number theory}

``Transcendence'' as a mathematical jargon first appeared in a Leibniz's 1682 paper where he proved that $\sin$ is a transcendental function in the sense that for any natural number $n$ there does not exist polynomials $p_0,\cdots,p_n$ such that
$$p_0(x)+p_1(x)\sin(x)+p_2(x)\sin(x)^2+\cdots+p_n(x)\sin(x)^n=0$$
holds for all $x\in\mathbb R$ \cite{bourbaki1998elements}. The Swiss mathematician Johann Heinrich Lambert in his 1768 paper proved the irrationality of $e$ and $\pi$ where he also conjectured their transcendence \cite{lambert2004memoire}. It is until 1844 that Joseph Liouville proved the existence of any transcendental numbers and until 1851 an explicit example of transcendental number is actually given by its decimal expansion:\cite{10.2307/1988833}
$$\sum_{i=1}^\infty\frac1{10^{i!}}=0.11000100000\cdots.$$
However, this construction is still artificial in nature. The first example of a real number proven to be transcendental that is not constructed for the purpose of being transcendental was $e$. Charles Hermite proved the transcendence of $e$ in 1873 with a method applicable with help of symmetric polynomial to transcendence of $\pi$ in 1882 and later to be generalised to Lindemann-Weierstrass theorem in 1885 stating that if $\alpha_1,\cdots, \alpha_n$ are distinct algebraic numbers then $e^{\alpha_1},\cdots,e^{\alpha_n}$ are linearly independent over the algebraic numbers \cite{baker1990transcendental}. The transcendence of $\pi$ was particularly celebrated because it immediately implied the impossibility of the ancient greek question of squaring the circle, i.e. it is not possible to construct a square, using compass and ruler only, with equal area to a circle. For this question is plainly equivalent to construct $\sqrt\pi$ which is not possible for otherwise $\pi$ is algebraic. Georg Cantor in 1874 proved that algebraic numbers are countable hence not only did transcendental numbers exist, they exist in a ubiquitous manner -- there is a bijection from the set of all transcendental numbers to $\mathbb R$ \cite{cantor1932uber,cantor1878beitrag}.

In 1900, Hilbert proposed twenty-three questions, the 7th of which is regarding transcendental numbers: Is $a^b$ transcendental, for any algebraic number $a$ that is not $0$ or $1$ and any irrational algebraic number $b$? The answer is yes by Gelfond-Schneider theorem in 1934 \cite{gelfond1934septieme}. This has some immediate consequences such that
\begin{enumerate}
  \item $2^{\sqrt2}$ and its square root ${\sqrt2}^{\sqrt2}$ are transcendental;
  \item $e^{\pi}$ is transcendental for $e^{\pi}=\left(e^{i\pi}\right)^{-i}=\left(-1\right)^{-i}$;
  \item $i^i=e^{-\frac\pi2}$ is transcendental etc.
\end{enumerate}
In contrast, none of $\pi\pm e$, $\pi e$,$\frac\pi e$, $\pi^\pi$, $\pi^e$ etc are proven to be transcendental. It is also conjectured by Stephen Schanuel that given any $n$ $\mathbb Q-$linearly independent $z_1,\cdots, z_n\in\mathbb C$, then $\mathrm{trdeg}\left(\mathbb Q(z_1,\cdots, zn, e^{z_1},\cdots, e^{z_n})/\mathbb Q\right)$ is at least $n$ \cite{lang1966introduction}. If this were proven, the algebraic independence of $e$ and $\pi$ would follow immediately by setting $z_1=1$ and $z_2=\pi i$ with Euler's identity.

\chapter{Brief introduction to {\tt Lean}}\label{intro:lean}

{\tt Lean} is developed by Leonardo de Moura at Microsoft Research Redmond from 2013 using dependent type theory and calculus of inductive constraint \cite{avigad2015theorem}. In this chapter, basic ideas of Curry-Howard isomorphism will be demonstrated by some basic examples of mathematical theorem expressed in {\tt Lean} using dependent type theory.

\section{Simple type theory}
Unlike set theory where everything from natural numbers to modular forms is essentially a set. Type theory associate every expression with a {\tt type}. In set theory, an element can belongs to different sets, for example $0$ is simultaneously in $\mathbb N\subseteq\mathbb Q\subseteq\mathbb R\subseteq\mathbb C$. However an expression can only have one type. $0$ without any context will have type $\mathbb N$ and, to specify the zero with type $\mathbb R$ we write $(0:\mathbb R)$. If $a$ has type $\alpha$, we write $a:\alpha$. By a universe of types we mean a collection of types.Types can be combined to form new types in the following way:
\begin{itemize}
  \item let $\alpha$ and $\beta$ be types then $\alpha\to\beta$ is the type of functions from $\alpha$ to $\beta$: the element of type $\alpha\to\beta$ is a function that for any element of $\alpha$ gives an element of $\beta$. For mathematician this loosely means that for any two classes $\alpha$ and $\beta$, there is a new class $\hom(\alpha,\beta)$. Sometimes we are not bothered to give a function a name, we can use the $\lambda$ notation: $(\lambda x:\alpha, \text{expression})$ has type $\alpha\to\dots$ depending on the content of expression. This can be thought of $\mapsto$. For example $(\lambda x:\mathbb N, x+1):\mathbb{N}\to\mathbb{N}$.
  \item let $\alpha$ and $\beta$ be types then $\alpha\times\beta$ is the cartesian product of $\alpha$ and $\beta$: the element of type $\alpha\times\beta$ is an ordered tuple $(a,b)$ where $a:\alpha$ and $b:\beta$.
  \item Let $\alpha$ be a type in universe $\mathcal U$ and $\beta:\alpha\to\mathcal U$ be a family of type that for any $a:\alpha$,$\beta(a)$ is a type in $\mathcal U$. Then we can form the $\Pi$-type $$\prod_{a:\alpha}\beta(a)$$ whose element is of the form $f:\prod_{a:\alpha}\beta(a)$ such that for any $x:\alpha$, $f(x):\beta(x)$. Note that function type is actually an example of $\Pi$-type where $\beta$ is a constant family of types. For this reason, we also call $\Pi$-types dependent functions. For example if $\mathrm{Vec}(\mathbb{R},n)$ is the type of $\mathbb R^n$, then 
    $$n\mapsto\underbrace{(1,\cdots,1)}_{n\text{ times}}:\prod_{m:\mathbb N} \mathrm{Vec}(\mathbb R, m)$$.
  % \item We also have dependent cartesian product or $\Sigma$-type: Let $\alpha$ be a type in universe $\mathcal U$ and $\beta:\alpha\to\mathcal U$ be a family of types in $\mathcal U$, then the $\Sigma$-type $$\sum_{a:\alpha}\beta(a)$$ whose element is of the form $(x,y):\sum_{a:\alpha}\beta(a)$ such that $x:\alpha$ and $y:\beta(x)$. Similarly $$\left(n,\underbrace{(1,\cdots,1)}_{n\text{ times}}\right):\sum_{m:\mathbb N} \mathrm{Vec}(\mathbb R, m)$$.
\end{itemize}

\subsection{Proposition as type}
In type theory, a proposition $p$ can be thought as a type whose elements is a proof of $p$.

\begin{example}
$1+1=2$ is a proposition. \mintinline{Lean}{rfl} is an element of type $1+1=2$ where \mintinline{Lean}{rfl} is the assertion that every term equals to itself.
\end{example}

\begin{example}
For two propositions $p$ and $q$, the implication $p\implies q$ then can be interpreted as function $p\to q$. To say $\mathrm{imp}: p\to q$ is to say for any $\mathrm{hp}:p$ we have $\mathrm{imp}( \mathrm{hp}): q$, or equivalently given any $\mathrm{hp}$, a {\it proof} of proposition $p$, $\mathrm{imp}(\mathrm{hp})$ is a proof of proposition $q$. 
\end{example}

\begin{example}
If $p:\alpha\to\mathrm{proposition}$
$\forall x : \alpha, p(x)$ can be interpreted as a $\Pi$-type $\prod_{x:\alpha} p(x)$. To prove $\forall x: \alpha, p(x)$, we need to find an element of type $\prod_{x:\alpha} p(x)$, equivalently for any $x:\alpha$, we need to find an element of type $p(x)$, equivalently for any $x:\alpha$, we need to find a proof of $p (x)$.

Similarly, $\exists x:\alpha, p(x)$ can be interpreted as a $\Sigma$-type $\sum_{x:\alpha} p(x)$. To prove $\exists x:\alpha, p(x)$ is to find an element $x$ of type $\alpha$ and prove $p(x)$, equivalently to find an element $x:\alpha$ and an element of type $p(x)$ and this is precisely $(x, p(x)):\sum_{a:\alpha} p(a)$.
\end{example}

Theorems are true propositions, using the interpretation above, theorems are inhabited types and to prove a theorem is to find an element of the required type.

\section{{\tt Lean} and {\tt mathlib}}
{\tt mathlib} is {\it the} collection of mathematical definition, theorems, lemmas built on {\tt Lean}. {\tt mathlib} includes topics in algebra, topology, manifolds and combinatorics etc. In this section, we are going to explain briefly how to use {\tt Lean} with {\tt mathlib}.


In {\tt Lean}, new definition can be introduced with the following syntax:
\begin{minted}[mathescape,linenos,numbersep=5pt,frame=lines,framesep=2mm,breaklines,escapeinside=||]{Lean}
def name (arg|$_1$|:type|$_1$|) ... (arg|$_n$|:type|$_n$|) : return_type := contents

def name' {arg|$_1$|:type|$_1$|} ... (arg|$_n$|:type|$_n$|) : return_type := contents
\end{minted}
Sometimes {\tt return\_type} can be dropped when it can be inferred from {\tt contents}. If an argument is surrounded by curly bracket instead of round bracket, then when the definition is invoked the said argument is implicit, i.e. {\tt name' a$_2$ ... a$_n$} where {\tt a$_i$:type$_i$}. To explicitly mention the said argument, one needs to use {\tt @name' a$_1$ ... a$_n$} where {\tt a$_i$:type$_i$}
Theorems or lemmas are introduced with the following syntax:
\begin{minted}[mathescape,linenos,numbersep=5pt,frame=lines,framesep=2mm,breaklines,escapeinside=||]{Lean}
theorem name (arg|$_1$|:type|$_1$|) ... (arg|$_n$|:type|$_n$|) : content :=
begin
  -- proof of the theorem
end
\end{minted}

To write a proof understandable to {\tt Lean}, one need to use {\it tactic mode}, i.e. a sequence of commands to convert a goal into another set of goals. 

% In the formalisation, {\tt simp}, {\tt ring}, {\tt rw}, {\tt apply}, {\tt linarith}, {\tt replace}, {\tt generalise}, {\tt refl}, {\tt exact}, {\tt split}, {\tt suffices}, {\tt norm\_cast}, {\tt norm\_num}, {\tt ext} and {\tt choose} are used.

\begin{itemize}
  \item \mintinline{Lean}{have H := content} will introduce a new proposition whose proof is given by {\tt content}.
  
  \mintinline{Lean}{have H : some_proposition} will add one more goal of proving the proposition then introduce the proved proposition to the current context.

  \item {\tt unfold definition} is to unfold a definition to what is explicitly defined when the definition is introduced.
  \item If the goal is a proposition about natural number $n$, {\tt induction n with n IH} is to prove the proposition by induction. This command will change the current goal to two goals. The first goal is to prove the proposition for $n=0$ and the second goal is to prove the proposition $n+1$ with the additional inductive hypothesis {\tt IH}.
  \item If the goal is to prove {\tt h1$\to$h2} then \mintinline{Lean}{intro h1} will add {\tt h1} to current context and convert the goal to prove {\tt h2}.
  
  Similarly if the goal is to prove {\tt $\forall $x:type, property\_about\_x}, then {\tt intro x} will fix an arbitrary {\tt x:type} then convert the goal to prove {\tt property\_about\_x}.

  There is also {\tt intros} to prove goals like {\tt h1$\to$...$\to$hn} or {\tt $\forall$x,$\forall$y,...} instead of using {\tt intro} multiple times.

  \item {\tt simp} will simplify the goal with lemmas with an \mintinline{Lean}{@[simp]} tag. These lemmas are usually small and trivial like $\forall m\in\mathbb N, 0+m=0$\footnote{this one is called {\tt nat.zero\_add}}.
  
  \mintinline{Lean}{simp only [h1, ..., hn]} is to simplify only using {\tt h1 }\dots{\tt{ hn}}.
  \item {\tt ring} will try to prove the current goal using associativity and commutativity of addition and multiplication.
  \item {\tt rw} is for term rewriting. For example, if we have \mintinline{Lean}{h : lhs = rhs} or \mintinline{Lean}{lhs<->rhs}, then \mintinline{Lean}{rw h} will replace every occurrence of {\tt lhs} with {\tt rhs} and \mintinline{Lean}{rw <-h} will replace every occurrence of {\tt rhs} with {\tt lhs}. 
  
  \mintinline{Lean}{rw [h1, h2,..., hn]} is the same as \mintinline{Lean}{rw h1, rw h2,..., rw hn}.
  \item Given (a proof of) proposition \mintinline{Lean}{H:h1->h2}, then \mintinline{Lean}{apply H} will change the goal of proving \mintinline{Lean}{h2} to prove \mintinline{Lean}{h1}.
  \item \mintinline{Lean}{linarith} is used when proving inequality from context. \mintinline{Lean}{linarith} is semi-automated, so it can work with inequalities with symbols or variables but only to a degree. If \mintinline{Lean}{linarith} failed, one has to either provide \mintinline{Lean}{linarith} with more propositions or use other tactics to change goal into something more manageable for \mintinline{Lean}{linarith}.
  
  \mintinline{Lean}{linarith [h1, ..., hn]} is equivalent to use \mintinline{Lean}{linarith} with additional (proofs of) propositions {\tt h1} \dots {\tt { hn}}.
  \item If {\tt H} is already in context then \mintinline{Lean}{replace H := content} will change {\tt H} to the proposition that {\tt content} is proving. 
  
  \mintinline{Lean}{replace H : some_proposition} will add one more goal of proving \mintinline{Lean}{some_proposition} and then replace {\tt H} to the proposition proven.
  \item \mintinline{Lean}{generalise H : lhs = var_name} will set {\tt var\_name} to {\tt lhs} and add (proof of) the proposition \mintinline{Lean}{H : lhs = var_name} to the current context.
  \item {\tt refl} (for reflexive) is used to prove proposition of the form {\tt lhs = rhs} when {\tt lhs} is {\bf definitionally} equal to {\tt rhs}. Definitional equality is more general than two string being literally identical but is less general than being (canonical) isomorphic. For example
  $$
\sum_{i=0}^\infty \frac{1}{2^i}=\sum_{j=0}^\infty \frac{1}{2^j}
  $$
  is a definitional equality but
  $$
\mathbb R^n = \mathrm{Func}\left(\{0,\cdots, n-1\},\mathbb R\right)
  $$ is not a definitional equality (strictly speaking perhaps not an equality at all).
\item {\tt exact H} will prove current goal if the goal is definitionally equal to H. 
\item \mintinline{Lean}{split} is used to prove goal of the form $h_1 \land h_2$. It will change the current goal to two goals of proving $h_1$ and $h_2$ respectively.
\item \mintinline{Lean}{suffices H : some_proposition} ask a proof of the current goal with additional {\tt H}, then ask for a proof of {\tt H}.
\item \mintinline{Lean}{norm_cast} is convert the type of numbers. For example the current goal is $(x:\mathbb R)<(y:\mathbb R)$ where $x$ and $y$ are of type $\mathbb N$, then after \mintinline{Lean}{norm_cast} the goal will become $x<y$. This should be simpler because $\mathbb R$ in {\tt Lean} is equivalent classes of Cauchy sequence of $\mathbb Q$ while natural number is much easier to work with.

\mintinline{Lean}{norm_num} is equivalent to \mintinline{Lean}{norm_cast, simp}.
\item \mintinline{Lean}{ext} will convert the current goal with axioms of extensionality. For example if the goal is to prove equality of polynomial then after {\tt ext} the goal would become to prove that every coefficient is equal; or if the goal is to prove equality of sets of type $\alpha$ $A=B$, then after {\tt ext}, an arbitrary element {\tt x} of type $\alpha$ will be introduced to context then the goal will become to prove $x\in A\iff x\in B$. {\tt ext var\_name} will force {\tt Lean} to introduce new variable under the identifier {\tt var\_name}.
\item If \mintinline{Lean}{H : ∃ x : type, property_about_x} is in the current context, \mintinline{Lean}{choose x hx using H} will introduce {\tt x:type} with the assumption {\tt property\_about\_x} to the current context. 
\item If there is multiple goals, one can use {\tt \{ \}} to focus on the first one.
\end{itemize}

A proposition if not atomic is either a conjunction, a disjunction, or a proposition bounded by universal quantifier or existential quantifier.

If goal is to prove a conjunction, for example $p \land q$. Then the general pattern of how a proof proceeds


\begin{example}
We can define the mean value of two real numbers by
\begin{minted}[mathescape,linenos,numbersep=5pt,frame=lines,framesep=2mm,breaklines,escapeinside=||]{Lean}
def mean (x y : ℝ) : ℝ := (x + y) / 2
\end{minted}
Then \mintinline{Lean}{mean}\footnote{\mintinline{Lean}{mean} is not a function $\mathbb R^2\to\mathbb R$ but a function $\mathbb R\to\mathrm{Func}(\mathbb R,\mathbb R)$. This is called currying of a function} has type $\mathbb R\to \mathbb R\to \mathbb R$, \mintinline{Lean}{mean 1} has type $\mathbb R\to \mathbb R$ and \mintinline{Lean}{mean 1 2} has type $\mathbb R$. We can introduce and prove a little theorem about \mintinline{Lean}{mean} that the mean value of two numbers is greater than or equal to the minimum of the two numbers.
\begin{minted}[mathescape,linenos,numbersep=5pt,frame=lines,framesep=2mm,breaklines,escapeinside=||]{Lean}
theorem min_le_mean (x y : ℝ) : min x y ≤ (mean x y) :=
begin
have ineq1 : min x y ≤ x := min_le_left x y,
have ineq2 : min x y ≤ y := min_le_right x y,
  
unfold mean, rw le_div_iff, rw mul_two, 
apply add_le_add, 
exact ineq1, exact ineq2, 

linarith,
end
\end{minted}
where
\begin{itemize}
\item \mintinline{Lean}{min_le_left} is a proof of the proposition $\forall (x\ y : type), \min(x, y) \le x$ where $type$ is an implicit argument with a linear order defined. In this case, {\tt Lean} infers from context that $type$ is $\mathbb R$. Thus \mintinline{Lean}{min_le_left x y} is a proof of \mintinline{Lean}{min x y ≤ x}.
\item \mintinline{Lean}{min_le_right} is a proof of the proposition $\forall (x\ y : type), \min(x, y) \le y$ where $type$ is an implicit argument with a linear order defined. In this case, {\tt Lean} infers from context that $type$ is $\mathbb R$. Thus \mintinline{Lean}{min_le_right x y} is a proof of \mintinline{Lean}{min x y ≤ y}.
\item \mintinline{Lean}{le_div_iff} is a proof that $0 < c \to (a \le \frac{b}{c} \iff a\times c \le b)$ where $a,b,c$ are elements of a linear ordered field structure. So by \mintinline{Lean}{le_div_iff}, the goal would change from {\tt min x y ≤ (x + y) / 2} to {\tt min x y * 2 ≤ x + y}. Since \mintinline{Lean}{le_div_iff} requires the assumption that $0<c$, a new goal is created after the original goal to prove that {\tt 0 < 2} which is proved by the final \mintinline{Lean}{linarith}.
\item \mintinline{Lean}{mul_two} proves the lemma that $\forall n:\alpha, n\times 2 = n+n$ where $\alpha$ is a semiring. Thus {\tt rw mul\_two} would change the goal of proving {\tt min x y * 2 ≤ x + y} to {\tt min x y + min x y ≤ x + y}.
\item \mintinline{Lean}{add_le_add} proves the lemma that $a \le b \to c \le d \to a + c \le b + d$ where $a$, $b$, $c$ and $d$ are elements of an ordered additive commutative monoid. Since the goal now is to prove {\tt min x y + min x y ≤ x + y}, by {\tt apply add\_le\_add}, goal will be replaced by two goals of proving {\tt min x y ≤ x} and {\tt min x y ≤ y}. These are {\it exactly} {\tt ineq1} and {\tt ineq2}.
\end{itemize}
\end{example}

\chapter{Formalisation using {\tt Lean}}\label{fmlsn}

% algebraic_over_Z.lean
% % small_things.lean
% e_trans_helpers2.lean
% e_transcendental.lean
% liouville.lean

\section*{Logistics of the formalisation}
\addcontentsline{toc}{section}{Logistics of the formalisation}
There are five main files in the formalisation where 
\begin{enumerate}
\item {\tt small\_things.lean} formalised results about the trivial embedding of $\mathbb Z[X]\subset \mathbb R[X]$ and manipulation of inequality in real numbers common to all three parts;
\item 1234
\end{enumerate}

\section{Countability argument}\label{fmlsn:count}
\section{Liouville's theorem and Liouville's number}\label{fmlsn:li}
\section{Hermite's proof of transcendence of $e$}\label{fmlsn:e}

\chapter{Further Work}

%% \section{Reflection}

%\bibliographystyle{alphanat}
\nocite{*}
\printbibliography

\end{document}
