\documentclass{report}
% \usepackage{hyperref}
\usepackage{fontspec}
\setmainfont{CMU Serif}
\setmonofont{FiraCode-Regular}

\usepackage[style=alphabetic,natbib=true]{biblatex}
\addbibresource{ref.bib}

\usepackage{amsmath}
\usepackage{amsthm}
\usepackage{amsfonts}
\theoremstyle{definition}
\newtheorem{example}{Example}
\newtheorem{lemma}{Lemma}[section]
\theoremstyle{plain}
\newtheorem{theorem}{Theorem}[section]

\usepackage[newfloat]{minted}
\usemintedstyle{bw}

\usepackage{caption}

\newenvironment{code}{\captionsetup{type=listing}}{}
\SetupFloatingEnvironment{listing}{name=Source Code}
% \setminted{fontsize=\footnotesize}

\title{A formalisation of transcendence of $e$}
\author{Jujian Zhang}

\begin{document}
\maketitle

% Abstract
\begin{abstract}
The objective of this report is to present formalizations of some basic theorems from transcendental number theory with {\tt Lean} and {\tt mathlib} in the hope that it will serve as a motivation for mathematicians to be more curious about interactive theorem proving. The following theorems are formalized:
\begin{enumerate}
  \item the set of algebraic numbers is countable, hence transcendental number exists:

\begin{minted}[mathescape,linenos,numbersep=5pt,frame=single,framesep=2mm,fontsize=\footnotesize]{Lean}
theorem algebraic_set_countable : set.countable algebraic_set
theorem transcendental_number_exists : 
  ∃ x : ℝ, transcendental x
\end{minted}

  \item all Liouville numbers are transcendental:
\begin{minted}[mathescape,linenos,numbersep=5pt,frame=single,framesep=2mm,fontsize=\footnotesize]{Lean}
theorem liouville_numbers_transcendental : 
  ∀ x : ℝ, liouville_number x -> transcendental x
\end{minted}

  \item $\alpha := \sum_{i=0}^\infty\frac1{10^{i!}}$ is a Liouville number hence $\alpha$ is transcendental.

\begin{minted}[mathescape,linenos,numbersep=5pt,frame=single,framesep=2mm,fontsize=\footnotesize]{Lean}
theorem liouville_α : liouville_number α
theorem transcendental_α : transcendental α := 
  liouville_numbers_transcendental α liouville_α
\end{minted}

  \item $e$ is transcendental:
\begin{minted}[mathescape,linenos,numbersep=5pt,frame=single,framesep=2mm,fontsize=\footnotesize]{Lean}
theorem e_transcendental : transcendental e
\end{minted}
\end{enumerate}
\end{abstract}

% \section* {Disclaimer}
% The plan is to a self-contained report so that after chapter \ref{intro:lean} any reader even without prior exposure to interactive theorem proving will be able to understand \ref{fmlsn} where the details of formalizations and proofs reside. This should be relatively straightforward since the author is a {\tt Lean}-dilettantes at best with only a partial picture of the full language. For the same reason, much of the code is perhaps not idiomatic or even plainly bad, thus it is not advisable to use this as a tutorial.

\tableofcontents

\chapter{Overview}
\section{Interactive theorem proving}
Around 1920s, the German mathematician David Hilbert put forward the Hilbert programme to seek:
\begin{enumerate}
  \item an axiomatic foundation of mathematics;
  \item a proof of consistency of the said foundation;
  \item Entscheidungsproblem: an algorithm to determine if any proposition is universally valid given a set of axioms.
\end{enumerate}
The first two aims were later proved to be impossible by Gödel and the celebrated incompleteness theorems. Via the completeness of first order logic, the Entscheidungsproblem can also be interpreted as an algorithm for producing proofs using deduction rules. Even without a panacea approach for mathematics, computer still bears advantages against a carbon-based mathematician. Perhaps the most manifested advantage is the accuracy of a computer to execute its command and to recall its memories. Thus came the idea of {\bf interactive theorem proving} --- instead of hoping a computer algorithm to spit out some unfathomable proofs, assuming computers are given the ability to check correctness of proofs, human-comprehensible proofs can be verified by machines and thus guaranteed to be free of errors. With a collective effort, all theorems verified this way can be collected in an error-free library such that all mathematicians can utilise to prove further theorems which can then be added to the collection, ad infinitum \cite{boyer1994qed}. Curry-Howard isomorphism provided the crucial relationship between mathematical proofs and computer programmes, more specifically relationship between propositions and types, to make such project feasible \cite{kennedy2011set}. The idea will be explained in section \ref{intro:lean} along with {\tt Lean}. 

The proof of ``Kepler's conjecture\footnote{the most efficient way to pack spheres should be hexagonally}'' will serve as an illustrative example of utility of interactive theorem proving. As early as 1998, Thomas Hales had claimed a proof \cite{hales1998kepler,harrison2014history}, however the proof is controversial in the sense that mathematician even with great effort could not guarantee its correctness. A collaborative project using {\tt Isabelle}\footnote{a theorem prover relies extensively on dependent type theory and Curry-Howard correspondence.} and {\tt HOL Light}\footnote{ibid.} verified the proof around 2014 and hence settled the controversy in 2017 \cite{hales2017formal}. There is also Georges Gonthier with his teams using {\tt Coq}\footnote{ibid.} who formalised the four colour theorem and Feit-Thompson theorem where the latter is a step to the classification of simple groups \cite{gonthier2008formal, gonthier2013machine}. Using {\tt Lean}\footnote{ibid.}, \Citeauthor{buzzard2020formalising} were able to formalise modern notion of perfectoid spaces \cite{buzzard2020formalising}.

\section{History of transcendental numbers}

``Transcendence'' as a mathematical jargon first appeared in a Leibniz's 1682 paper where he proved that $\sin$ is a transcendental function in the sense that for any natural number $n$ there does not exist polynomials $p_0,\cdots,p_n$ such that
$$p_0(x)+p_1(x)\sin(x)+p_2(x)\sin(x)^2+\cdots+p_n(x)\sin(x)^n=0$$
holds for all $x\in\mathbb R$ \cite{bourbaki1998elements}. The Swiss mathematician Johann Heinrich Lambert in his 1768 paper proved the irrationality of $e$ and $\pi$ where he also conjectured their transcendence \cite{lambert2004memoire}. It is until 1844 that Joseph Liouville proved the existence of any transcendental numbers and until 1851 an explicit example of transcendental number is actually given by its decimal expansion:\cite{10.2307/1988833}
$$\sum_{i=1}^\infty\frac1{10^{i!}}=0.11000100000\cdots.$$
However, this construction is still artificial in nature. The first example of a real number proven to be transcendental that is not constructed for the purpose of being transcendental was $e$. Charles Hermite proved the transcendence of $e$ in 1873 with a method applicable with help of symmetric polynomial to transcendence of $\pi$ in 1882 and later to be generalised to Lindemann-Weierstrass theorem in 1885 stating that if $\alpha_1,\cdots, \alpha_n$ are distinct algebraic numbers then $e^{\alpha_1},\cdots,e^{\alpha_n}$ are linearly independent over the algebraic numbers \cite{baker1990transcendental}. The transcendence of $\pi$ was particularly celebrated because it immediately implied the impossibility of the ancient greek question of squaring the circle, i.e. it is not possible to construct a square, using compass and ruler only, with equal area to a circle. For this question is plainly equivalent to construct $\sqrt\pi$ which is not possible for otherwise $\pi$ is algebraic. Georg Cantor in 1874 proved that algebraic numbers are countable hence not only did transcendental numbers exist, they exist in a ubiquitous manner -- there is a bijection from the set of all transcendental numbers to $\mathbb R$ \cite{cantor1932uber,cantor1878beitrag}.

In 1900, Hilbert proposed twenty-three questions, the 7th of which is regarding transcendental numbers: Is $a^b$ transcendental, for any algebraic number $a$ that is not $0$ or $1$ and any irrational algebraic number $b$? The answer is yes by Gelfond-Schneider theorem in 1934 \cite{gelfond1934septieme}. This has some immediate consequences such that
\begin{enumerate}
  \item $2^{\sqrt2}$ and its square root ${\sqrt2}^{\sqrt2}$ are transcendental;
  \item $e^{\pi}$ is transcendental for $e^{\pi}=\left(e^{i\pi}\right)^{-i}=\left(-1\right)^{-i}$;
  \item $i^i=e^{-\frac\pi2}$ is transcendental etc.
\end{enumerate}
In contrast, none of $\pi\pm e$, $\pi e$,$\frac\pi e$, $\pi^\pi$, $\pi^e$ etc are proven to be transcendental. It is also conjectured by Stephen Schanuel that given any $n$ $\mathbb Q-$linearly independent $z_1,\cdots, z_n\in\mathbb C$, then $\mathrm{trdeg}\left(\mathbb Q(z_1,\cdots, zn, e^{z_1},\cdots, e^{z_n})/\mathbb Q\right)$ is at least $n$ \cite{lang1966introduction}. If this were proven, the algebraic independence of $e$ and $\pi$ would follow immediately by setting $z_1=1$ and $z_2=\pi i$ with Euler's identity.

\chapter{Brief introduction to {\tt Lean}}\label{intro:lean}

{\tt Lean} is developed by Leonardo de Moura at Microsoft Research Redmond from 2013 using dependent type theory and calculus of inductive constraint \cite{avigad2015theorem}. In this chapter, basic ideas of Curry-Howard isomorphism will be demonstrated by some basic examples of mathematical theorem expressed in {\tt Lean} using dependent type theory.

\section{Simple type theory}
Unlike set theory where everything from natural numbers to modular forms is essentially a set. Type theory associate every expression with a {\tt type}. In set theory, an element can belongs to different sets, for example $0$ is simultaneously in $\mathbb N\subseteq\mathbb Q\subseteq\mathbb R\subseteq\mathbb C$. However an expression can only have one type. $0$ without any context will have type $\mathbb N$ and, to specify the zero with type $\mathbb R$ we write $(0:\mathbb R)$. If $a$ has type $\alpha$, we write $a:\alpha$. By a universe of types we mean a collection of types.Types can be combined to form new types in the following way:
\begin{itemize}
  \item let $\alpha$ and $\beta$ be types then $\alpha\to\beta$ is the type of functions from $\alpha$ to $\beta$: the element of type $\alpha\to\beta$ is a function that for any element of $\alpha$ gives an element of $\beta$. For mathematician this loosely means that for any two classes $\alpha$ and $\beta$, there is a new class $\hom(\alpha,\beta)$. Sometimes we are not bothered to give a function a name, we can use the $\lambda$ notation: $(\lambda x:\alpha, \text{expression})$ has type $\alpha\to\dots$ depending on the content of expression. This can be thought of $\mapsto$. For example $(\lambda x:\mathbb N, x+1):\mathbb{N}\to\mathbb{N}$.
  \item let $\alpha$ and $\beta$ be types then $\alpha\times\beta$ is the cartesian product of $\alpha$ and $\beta$: the element of type $\alpha\times\beta$ is an ordered tuple $(a,b)$ where $a:\alpha$ and $b:\beta$.
  \item Let $\alpha$ be a type in universe $\mathcal U$ and $\beta:\alpha\to\mathcal U$ be a family of type that for any $a:\alpha$,$\beta(a)$ is a type in $\mathcal U$. Then we can form the $\Pi$-type $$\prod_{a:\alpha}\beta(a)$$ whose element is of the form $f:\prod_{a:\alpha}\beta(a)$ such that for any $x:\alpha$, $f(x):\beta(x)$. Note that function type is actually an example of $\Pi$-type where $\beta$ is a constant family of types. For this reason, we also call $\Pi$-types dependent functions. For example if $\mathrm{Vec}(\mathbb{R},n)$ is the type of $\mathbb R^n$, then 
    $$n\mapsto\underbrace{(1,\cdots,1)}_{n\text{ times}}:\prod_{m:\mathbb N} \mathrm{Vec}(\mathbb R, m)$$
  \item We also have dependent cartesian product or $\Sigma$-type: Let $\alpha$ be a type in universe $\mathcal U$ and $\beta:\alpha\to\mathcal U$ be a family of types in $\mathcal U$, then the $\Sigma$-type $$\sum_{a:\alpha}\beta(a)$$ whose element is of the form $(x,y):\sum_{a:\alpha}\beta(a)$ such that $x:\alpha$ and $y:\beta(x)$. Similarly $$\left(n,\underbrace{(1,\cdots,1)}_{n\text{ times}}\right):\sum_{m:\mathbb N} \mathrm{Vec}(\mathbb R, m)$$
\end{itemize}

\subsection{Proposition as type}
In type theory, a proposition $p$ can be thought as a type whose elements is a proof of $p$.

\begin{example}
$1+1=2$ is a proposition. {\tt rfl} is an element of type $1+1=2$ where {\tt rfl} is the assertion that every term equals to itself.
\end{example}

\begin{example}
For two propositions $p$ and $q$, the implication $p\implies q$ then can be interpreted as function $p\to q$. To say $\mathrm{imp}: p\to q$ is to say for any $\mathrm{hp}:p$ we have $\mathrm{imp}( \mathrm{hp}): q$, or equivalently given any $\mathrm{hp}$, a {\it proof} of proposition $p$, $\mathrm{imp}(\mathrm{hp})$ is a proof of proposition $q$. 
\end{example}

\begin{example}
If $p:\alpha\to\mathrm{proposition}$
$\forall x : \alpha, p(x)$ can be interpreted as a $\Pi$-type $\prod_{x:\alpha} p(x)$. To prove $\forall x: \alpha, p(x)$, we need to find an element of type $\prod_{x:\alpha} p(x)$, equivalently for any $x:\alpha$, we need to find an element of type $p(x)$, equivalently for any $x:\alpha$, we need to find a proof of $p (x)$.

Similarly, $\exists x:\alpha, p(x)$ can be interpreted as a $\Sigma$-type $\sum_{x:\alpha} p(x)$. To prove $\exists x:\alpha, p(x)$ is to find an element $x$ of type $\alpha$ and prove $p(x)$, equivalently to find an element $x:\alpha$ and an element of type $p(x)$ and this is precisely $(x, p(x)):\sum_{a:\alpha} p(a)$.
\end{example}

Theorems are true propositions, using the interpretation above, theorems are inhabited types and to prove a theorem is to find an element of the required type.

\section{{\tt Lean} and {\tt mathlib}}
{\tt mathlib} is {\it the} collection of mathematical definition, theorems, lemmas built on {\tt Lean}. {\tt mathlib} includes topics in algebra, topology, manifolds and combinatorics etc. In this section, we are going to explain briefly how to use {\tt Lean} with {\tt mathlib}.


In {\tt Lean}, new definition can be introduced with the following syntax:
\begin{minted}[mathescape,linenos,numbersep=5pt,frame=single,framesep=2mm,breaklines,escapeinside=||]{Lean}
def name (arg|$_1$|:type|$_1$|) ... (arg|$_n$|:type|$_n$|) : return_type := contents

def name' {arg|$_1$|:type|$_1$|} ... (arg|$_n$|:type|$_n$|) : return_type := contents
\end{minted}
{\tt return\_type} is optional when it can be inferred from {\tt contents}. If an argument is surrounded by curly bracket instead of round bracket, then when the definition is invoked the said argument is implicit, i.e. {\tt name' a$_2$ ... a$_n$} where {\tt a$_i$:type$_i$}. To explicitly mention the said argument, one needs to use {\tt @name' a$_1$ ... a$_n$} where {\tt a$_i$:type$_i$}. One can use ``if then else'' to introduce a function whose value depends on the value of arguments:
\begin{minted}[mathescape,linenos,numbersep=5pt,frame=single,framesep=2mm,breaklines,escapeinside=||]{Lean}
def name args : return_type :=
  if (h args)
  then contents|$_1$|
  else contents|$_2$|

def name args : return_type := 
  ite (h args) contents|$_1$| contents|$_2$|
\end{minted}

New notations are introduced with the following syntax:
\begin{minted}[mathescape,linenos,numbersep=5pt,frame=single,framesep=2mm,breaklines,escapeinside=§§]{Lean}
notation _`lhs`_ := _rhs_
\end{minted}
so that {\tt Lean} will treat every occurrence of {\tt \_`lhs`\_} as {\tt \_rhs\_} verbatim. For example \mintinline{Lean}{notation ℤ`[X]` := polynomial ℤ} will replace the {\tt Lean} type {\tt polynomial ℤ} with a more family notation of $\mathbb{Z}[X]$.

For any type of $\alpha$, we can introduce a subtype of $\alpha$ by:
\begin{minted}[mathescape,linenos,numbersep=5pt,frame=single,framesep=2mm,breaklines,escapeinside=§§]{Lean}
def α' := {x : α // property_satisfied_by_x}
\end{minted}
An element of type $\alpha'$ is of the form $\langle x, hx\rangle$ where $x:\alpha$ and $hx$ is a proof that $x$ satisfies the given property.

Theorems or lemmas are introduced with the following syntax:
\begin{minted}[mathescape,linenos,numbersep=5pt,frame=single,framesep=2mm,breaklines,escapeinside=||]{Lean}
theorem name (arg|$_1$|:type|$_1$|) ... (arg|$_n$|:type|$_n$|) : content :=
begin
  -- proof of the theorem
end
\end{minted}

To write a proof understandable to {\tt Lean}, one need to use {\it tactic mode}. In {\tt Lean}, one can use
\begin{itemize}
  \item proof by induction: if the goal is a proposition about natural number $n$, {\tt induction n with n IH} is to prove the proposition by induction. This command will change the current goal to two goals. The first goal is to prove the proposition for $n=0$ and the second goal is to prove the proposition $n+1$ with the additional inductive hypothesis {\tt IH};

\begin{minted}[mathescape,linenos,numbersep=5pt,frame=single,framesep=2mm,breaklines,escapeinside=||]{Lean}
theorem awesome_theorem_about_natural_number (n : ℕ) : proposition|$_\mathtt{n}$| :=
begin
  induction n with n IH,

  a_proof_of_proposition|$_\mathtt{0}$|

  -- (IH : proposition$_\mathtt{n}$) is now in context
  a_proof_of_proposition|$_\mathtt{n+1}$|
end
\end{minted}

  \item proof by contradiction: if the goal is to prove proposition $H$, {\tt by\_contra absurdum} will add {\tt absurdum : $\neg H$} into the current context and turn the goal into proving {\tt false};

\begin{minted}[mathescape,linenos,numbersep=5pt,frame=single,framesep=2mm,breaklines,escapeinside=||]{Lean}
theorem awesome_theorem : awesome_proposition :=
begin
by_contra absurdum,

-- Now (absurdum : $\neg$ awesome_proposition) is in context and the goal is to prove falsehood.
a_proof_of_falsehood
end
\end{minted}
  \item proof in a forward manner i.e. introduce new theorem or convert known theorem in current context to approach the goal:
  \begin{itemize}
    \item {\tt have H := content} will introduce a new proposition whose proof is given by {\tt content}.
    
    {\tt have H : some\_proposition} will add one more goal of proving the proposition then introduce the proved proposition to the current context.

    \item If {\tt H} is in context then {\tt replace H := content} will change {\tt H} to (a proof of) the proposition that {\tt content} is proving.
    
    {\tt replace H : some\_proposition} will add one more goal of proving {\tt some\_proposition} and then replace {\tt H} to the proposition proven.
    \item If {\tt H} is in context, {\tt simp at H} will simplify {\tt H} to using small lemmas\footnote{to be more precise, lemma with {\tt @[simp]} tag, i.e. lemmas declared in the following syntax {\tt @[simp] lemma lemma\_name args : Prop}. These lemma are usually trivial in nature such as {\tt nat.add\_zero} which asserts that $\forall n:\mathbb N, n + 0 = n$.}.
    {\tt simp only [h1,\dots,hn]} is to simplify only using {\tt h1 }\dots{\tt{ hn}}.
    \item {\tt rw} is for term rewriting. If we have {\tt h : lhs = rhs} or {\tt h : lhs<->rhs} and another {\tt H} in context, then {\tt rw h at H} will replace every occurrence of {\tt lhs} with {\tt rhs} in {\tt H} and {\tt rw <-h} will replace every occurrence of {\tt rhs} with {\tt lhs} in {\tt H}.
  
    {\tt rw [h1, h2,..., hn] at H} is the same as {\tt rw h1 at H, rw h2 at H,..., rw hn at H}.
    
    \item Since {\tt rw} and {\tt simp} will change all occurrence, this sometimes would be inconvenient. If {\tt H} is in context, {\tt conv\_lhs at H \{tactics\}} will confine the scope of {\tt tactics} only to left hand side of H; similarly {\tt conv\_rhs at H \{tactics\}} will confine the scope to right hand side of H.

    \item {\tt generalise H : lhs = var\_name} will set {\tt var\_name} to {\tt lhs} and add (proof of) the proposition {\tt H : lhs = var\_name} to the current context.
    \item If {\tt H : ∃ x : type, property\_about\_x} is in the current context, {\tt choose x hx using H} will introduce {\tt x:type} with the assumption {\tt property\_about\_x} to the current context. 
    \item If {\tt H : $p\land q$} is in the current context, then {\tt H.1} is (a proof of) $p$ and {\tt H.2} is (a proof of) $q$.
    \item If {\tt H : ite h1 h2 h3} is in the current context, then {\tt split\_ifs at H} will turn the current goal into two goals, the first one is to prove the original goal with the additional assumption {\tt h1} and {\tt h2}; the second one is to prove the original with goal with the additional assumption {\tt $\neg$h1} and {\tt h3}.
  \end{itemize}

  \item proof in a backward manner i.e. convert or replace the goal so that it is closer to what is known in context:
  \begin{itemize}
    \item {\tt unfold definition} is to unfold a definition to what is explicitly defined when the definition is introduced.
    \item {\tt simp}, {\tt rw}, {\tt conv\_lhs \{tactics\}} and {\tt conv\_rhs \{tactics\}} is the same as above except now they change at goal.
    \item Given (a proof of) proposition {\tt H: h1 -> h2}, then {\tt apply H} will change the goal of proving {\tt h2} to prove {\tt h1}.
    \item {\tt suffices H : some\_proposition} ask a proof of the current goal with additional {\tt H}, then ask for a proof of {\tt H}.
    \item {\tt norm\_cast} is convert the type of numbers. For example the current goal is $(x:\mathbb R)<(y:\mathbb R)$ where $x$ and $y$ are of type $\mathbb N$, then after {\tt norm\_cast} the goal will become $x<y$. This should be simpler because $\mathbb R$ in {\tt Lean} is equivalent classes of Cauchy sequence of $\mathbb Q$ while natural number is much easier to work with.
    
    {\tt norm\_num} is equivalent to {\tt norm\_cast, simp}.

    \item {\tt ext} will convert the current goal with axioms of extensionality. For example if the goal is to prove equality of polynomial then after {\tt ext} the goal would become to prove that every coefficient is equal; or if the goal is to prove equality of sets of type $\alpha$ $A=B$, then after {\tt ext}, an arbitrary element {\tt x} of type $\alpha$ will be introduced to context then the goal will become to prove $x\in A\iff x\in B$. {\tt ext var\_name} will force {\tt Lean} to introduce new variable under the identifier {\tt var\_name}.
    \item If the goal is to prove {\tt ite h1 h2 h3} (or {\tt ite h1 h2 h3 = rhs}), then {\tt split\_ifs at H} will turn the current goal into two goals, the first one is to prove {\tt h2} ({\tt h3 = rhs} resp.) with additional assumption {\tt h1}; the second one is to prove {\tt h3} ({\tt h3 = rhs} resp.) with additional assumption {\tt $\neg$h1}
  \end{itemize}

  \item when the goal is easily provable, one can use the following to finish a goal:
  \begin{itemize}
    \item {\tt refl} (for reflexive) is used to prove proposition of the form {\tt lhs = rhs} when {\tt lhs} is {\bf definitionally} equal to {\tt rhs}. Definitional equality is more general than two string being literally identical but is less general than being (canonical) isomorphic. For example
    $$
  \sum_{i=0}^\infty \frac{1}{2^i}=\sum_{j=0}^\infty \frac{1}{2^j}
    $$
    is a definitional equality but
    $$
  \mathbb R^n = \mathrm{Func}\left(\{0,\cdots, n-1\},\mathbb R\right)
    $$ is not a definitional equality (strictly speaking perhaps not an equality at all).
    \item {\tt exact H} will prove current goal if the goal is definitionally equal to H. 
  
    \item {\tt ring} will try to prove the current goal using associativity and commutativity of addition and multiplication.
    \item {\tt linarith} is used when proving inequality from context. {\tt linarith} is semi-automated, so it can work with inequalities with symbols or variables but only to a degree. If {\tt linarith} failed, one has to either provide {\tt linarith} with more propositions or use other tactics to change goal into something more manageable for {\tt linarith}.
  
    {\tt linarith [h1, ..., hn]} is equivalent to use {\tt linarith} with additional (proofs of) propositions {\tt h1} \dots {\tt { hn}}.
  \end{itemize}

  \item If there is multiple goals, one can use {\tt \{ \}} to focus on the first one.
  \item If the entirety of proof is one line, one can replace {\tt begin contents end} with {\tt by contents}.
\end{itemize}


A proposition if not atomic is either a conjunction, a disjunction, an implication, an equivalence, a negation or a proposition with universal quantifier or existential quantifier.

\subsection*{prove a conjunction}\label{lean:conj}
If goal is to prove a conjunction of the form $h_1 \land h_2$, {\tt split} is used. It will change the current goal to two goals of proving $h_1$ and $h_2$ respectively. Then the general pattern is

\begin{minted}[mathescape,linenos,numbersep=5pt,frame=single,framesep=2mm,breaklines,escapeinside=||]{Lean}
theorem how_to_prove_conjunction (|$h_1$| : Prop) (|$h_2$| : Prop) : |$h_1\land h_2$| :=
begin
split,

proof_of_|$h_1$|

proof_of_|$h_2$|
end
\end{minted}


\subsection{prove a disjunction}\label{lean:disjun}
If the goal is to prove a disjunction of the form $h_1 \lor h_2$, one can use {\tt left} to change the goal to prove $h_1$ or {\tt right} to change the goal to prove $h_2$. Let us assume $h_1$ is a true proposition :

\begin{minted}[mathescape,linenos,numbersep=5pt,frame=single,framesep=2mm,breaklines,escapeinside=||]{Lean}
theorem how_to_prove_disjunction (|$h_1$| : Prop) (|$h_2$| : Prop) : |$h_1\lor h_2$| :=
begin
left,
  
proof_of_|$h_1$|
end
\end{minted}


\subsection{prove an implication}\label{lean:imp}
If the goal is to prove an implication of the form $p \implies q$, one can use {\tt intro h$p$} to add {\tt h$p$:$p$} a proof of $p$ into the context and convert goal to prove $q$.

\begin{minted}[mathescape,linenos,numbersep=5pt,frame=single,framesep=2mm,breaklines,escapeinside=||]{Lean}
theorem how_to_prove_implication (|$p$| : Prop) (|$q$| : Prop) : |$p$| -> |$q$| :=
begin
intro h|$p$|,
  
proof_of_|$q$|
end
\end{minted}

If the goal is of the form $p_1\to p_2\to\dots p_n$, one can use {\tt intros h$p_1$ \dots h$p_n$} as an abbreviation of {\tt intro h$p_1$, intro h$p_2$,\dots, intro h$p_n$}.


\subsection{prove an equivalence}\label{lean:eqv}
An equivalence of the form $p \iff q$ is by definition $p\implies q \land q\implies p$. Thus by {\tt split} will change the goal to two goals, one to prove $p\implies q$, the other to prove $q \implies p$. Then use section \ref{lean:imp}.

\subsection{prove a negation}
A negation of the form $\neg p$ is by definition $p \implies \bot$. Thus {\tt intro h$p$} will add {\tt h$p$:$p$} to current context and convert the goal to prove a falsehood.

\begin{minted}[mathescape,linenos,numbersep=5pt,frame=single,framesep=2mm,breaklines,escapeinside=||]{Lean}
theorem how_to_prove_negation (|$p$| : Prop) : |$\neg p$| :=
begin
intro h|$p$|,

proof_of_falsehood
end
\end{minted}

\subsection{prove a proposition with $\forall$}\label{lean:forall}
A proposition of the form $\forall a : \alpha, p(a)$ where $\alpha$ is a type and $p : \alpha\to {\tt Prop}$ can be proved also using {\tt intro $x_0$}. This will add an arbitrary $x_0:\alpha$ to the current context and change the goal to prove $p(x_0)$.

\begin{minted}[mathescape,linenos,numbersep=5pt,frame=single,framesep=2mm,breaklines,escapeinside=||]{Lean}
theorem how_to_proposition_with_universal_quantifier {|$\alpha$| : Type} (|$p$| : |$\alpha$| -> Prop) : ∀ a : α, p a :=
begin
intro |$x_0$|,

a_proof_of_|$p(x_0)$|
end
\end{minted}

If the goal is the form $\forall a_1:\alpha_1,\forall a_2:\alpha_2,\dots,\forall a_n:\alpha_n, p\ a_1\ a_2\ \dots\ a_n$ can be proved using {\tt intros $a_1$ $a_2$ \dots\  $a_n$} as an abbreviation of {\tt intro $a_1$, intro $a_2$,\dots, intro $a_n$}.

\subsection{prove a proposition with $\exists$}\label{lean:exists}
A proposition of the form $\exists a:\alpha, p(a)$ where $\alpha$ is a type and $p : \alpha\to {\tt Prop}$ can be proved by {\tt use $x_0$}. This will convert the goal to prove $p(x_0)$.

\begin{minted}[mathescape,linenos,numbersep=5pt,frame=single,framesep=2mm,breaklines,escapeinside=||]{Lean}
theorem how_to_proposition_with_universal_quantifier {|$\alpha$| : Type} (|$p$| : |$\alpha$| -> Prop) : ∃ a : α, p a :=
begin
a_construction_of_|$x_0$|

use |$x_0$|,
  
a_proof_of_|$p(x_0)$|
end
\end{minted}

\section{An example}
To illustrate the above syntax and patterns, we present an example of defining mean and proving some basic properties thereof.

\begin{minted}[mathescape,linenos,numbersep=5pt,frame=single,framesep=2mm,breaklines,escapeinside=||]{Lean}
import data.real.basic |\label{import:real}|
import tactic |\label{import:tactic}|
  
noncomputable theory |\label{noncomputable}|
open_locale classical |\label{proof_by_contradiction}|  

def mean (x y : ℝ) : ℝ := (x + y) / 2 |\label{example:def}|
  
theorem min_le_mean : ∀ x y : ℝ, min x y ≤ (mean x y) := |\label{example:thm_begin}|
begin
intros x y,
have ineq1 : min x y ≤ x := min_le_left x y,
have ineq2 : min x y ≤ y := min_le_right x y,
    
unfold mean, rw le_div_iff, rw mul_two, 
apply add_le_add, 
exact ineq1, exact ineq2, 
  
linarith,
end
  
theorem mean_le_max : ∀ x y : ℝ, (mean x y) ≤ max x y :=
begin
intros x y,
have ineq1 : x ≤ max x y := le_max_left x y,
have ineq2 : y ≤ max x y := le_max_right x y,
  
unfold mean, rw div_le_iff, rw mul_two,
apply add_le_add,
exact ineq1, exact ineq2,
  
linarith,
end |\label{example:thm_end}|
  
theorem a_number_in_between : 
  ∀ x y : ℝ, x ≤ y -> ∃ z : ℝ, x ≤ z ∧ z ≤ y :=
begin
intros x y hxy,
have ineq1 := min_le_mean x y,
have ineq2 := mean_le_max x y,
have min_eq_x := min_eq_left hxy,
have max_eq_y := max_eq_right hxy,
use mean x y,
split,
  
{ conv_lhs {rw <-min_eq_x}, exact ineq1, },
{ conv_rhs {rw <-max_eq_y}, exact ineq2, },
end

\end{minted}

Line \ref{import:real} will make basic properties of real available to use and line \ref{import:tactic} will make all the tactics we discussed amongst other more advanced tactics available to use. We add line \ref{noncomputable} so that {\tt lean} would ignore the issue of computability and line \ref{proof_by_contradiction} so that we can use proof by contradiction\footnote{{\tt Lean} by default use constructivism where $\neg\neg p\implies p$ is not an axiom of deduction. Thus the law of excluded middle is not by default a tautology.}. 

We define the mean value of two real numbers on line \ref{example:def}. Then {\tt mean}\footnote{{\tt mean} is not a function $\mathbb R^2\to\mathbb R$ but a function $\mathbb R\to\mathrm{Func}(\mathbb R,\mathbb R)$. This is called currying.} has type $\mathbb R\to \mathbb R\to \mathbb R$, {\tt mean 1} has type $\mathbb R\to \mathbb R$ and {\tt mean 1 2} has type $\mathbb R$. 

We can introduce and prove theorems about {\tt mean} that the mean value of two numbers is greater than or equal to the minimum of the two numbers but less than the maximum of the two numbers. This is from line \ref{example:thm_begin} to line \ref{example:thm_end} where
\begin{itemize}
  \item {\tt min\_le\_left} is a proof of the proposition $\forall (x\ y : \alpha), \min(x, y) \le x$ where $\alpha$ is an implicit argument with a linear order. In this case, {\tt Lean} infers from context that $\alpha$ is $\mathbb R$. Thus {\tt min\_le\_left x y} is a proof of {\tt min x y ≤ x}.
  \item {\tt min\_le\_right} is a proof of the proposition $\forall (x\ y : \alpha), \min(x, y) \le y$ In this case, {\tt min\_le\_right x y} is a proof of {\tt min x y ≤ y}.
  \item Similarly, {\tt le\_max\_left} is a proof of the proposition $\forall (x\ y : \alpha), x \le \max(x, y)$ where $\alpha$ is an implicit argument with a linear order. In this case, {\tt le\_max\_left} is a proof of {\tt x ≤ max x y}.
  \item Similarly, {\tt le\_max\_right} is a proof of the proposition $\forall (x\ y : \alpha), y \le \max(x, y)$ where $\alpha$ is an implicit argument with a linear order. In this case, {\tt le\_max\_right} is a proof of {\tt y ≤ max x y}.
  \item {\tt le\_div\_iff} is a proof that $0 < c \to (a \le \frac{b}{c} \iff a\times c \le b)$ where $a,b,c$ are elements of a type with a linear ordered field structure. So by {\tt rw le\_div\_iff}, the goal would change from {\tt min x y ≤ (x + y) / 2} to {\tt min x y * 2 ≤ x + y}. Since {\tt le\_div\_iff} requires the assumption that $0<c$, a new goal to prove that {\tt 0 < 2} is created after the original goal. This goal is proved by the final {\tt linarith}.
  \item {\tt div\_le\_iff} is proof that $0 < b \implies (\frac a b \le c \iff a \le c \times b)$ where $a,b,c$ are elements of a type with a linear ordered field structure. So by {\tt rw div\_le\_iff} the goal would change from {\tt (x + y) / 2 ≤ max x y} to {\tt x + y ≤ max x y * 2}. Since {\tt div\_le\_iff} requires the assumption that $0 < b$, a new goal to prove $0 < 2$ is created after the original goal. This goal is proved by the final {\tt linarith}.
  \item {\tt mul\_two} proves the lemma that $\forall n:\alpha, n\times 2 = n+n$ where $\alpha$ is a semiring. Thus {\tt rw mul\_two} would change the goal of proving {\tt min x y * 2 ≤ x + y} ({\tt x + y ≤ max x y * 2} resp.) to {\tt min x y + min x y ≤ x + y} ({\tt x + y ≤ max x y + max x y} resp.).
  \item {\tt add\_le\_add} proves the lemma that $a \le b \to c \le d \to a + c \le b + d$ where $a$, $b$, $c$ and $d$ are elements of an ordered additive commutative monoid. Since the goal now is to prove {\tt min x y + min x y ≤ x + y}, by {\tt apply add\_le\_add}, goal will be replaced by two goals of proving {\tt min x y ≤ x} and {\tt min x y ≤ y}. These are {\it exactly} {\tt ineq1} and {\tt ineq2}.
\end{itemize}

\chapter{Formalisation using {\tt Lean}}\label{fmlsn}
\section*{Logistics of the formalisation}
\addcontentsline{toc}{section}{Logistics of the formalisation}
There are five main files in the formalisation where 
\begin{enumerate}
\item {\tt small\_things.lean} formalised results about the trivial embedding of $\mathbb Z[X]\subset \mathbb R[X]$ and manipulation of inequality in real numbers common to all three parts;
\item {\tt algebraic\_over\_Z.lean} formalised countability of algebraic numbers. In this file we made an extensive use of Schröder-Berstein theorem.
\item {\tt liouville.lean} formalised Liouville's theorem and a construction of a Liouville's number;
\item {\tt e\_trans\_helpers2.lean} formalised some results about differentiation and integration. Especially the formalisations of 
$$
\frac{\mathrm d^n}{\mathrm d x^n}uv = \sum_{i=0}^n{n \choose i}\frac{\mathrm d^i u}{\mathrm d x^i}\frac{\mathrm d^{n-i} v}{\mathrm d x^{n-i}}
$$ where $u$ and $v$ are differentiable function from $\mathbb R$ to $\mathbb R$ and
$$
\int_0^t e^{t-x}f(x)\mathrm{d}x=e^t\sum_{i=0}^m f^{(i)}(0)-\sum_{i=0}^m f^{(i)}(t)
$$ where $f(X)\in\mathbb Z[X]$;
\item {\tt e\_transcendental.lean} formalised transcendence of $e$ by assuming the algebraicity of $e$ which resulted in two contradictory bounds using the results from {\tt e\_trans\_helpers2.lean}.
\end{enumerate}

\section{Countability argument}\label{fmlsn:count}
The main caveat in this part is internal specification of {\tt mathlib}. 
A real number $x$ is in {\tt Lean} is algebraic over $\mathbb Z$ if and only if there exists a nonzero polynomial $p(X)\in\mathbb Z[X]$ such that $p$ is in the kernel of the unqiue $\mathbb Z$-algebra homomorphism $\mathbb Z[X]\to\mathbb R$ given by $X\mapsto x$.
\begin{minted}[mathescape,linenos,numbersep=5pt,frame=single,framesep=2mm,breaklines,escapeinside=||]{Lean}
∃ (p : ℤ[X]), p ≠ 0 ∧ |$\Uparrow$|(polynomial.aeval ℤ ℝ x) p = 0
\end{minted}
Here the $\mathbb Z$-algebra homomorphism is {\tt polynomial.aeval ℤ ℝ x}. $\Uparrow$ is to convert the homomorphism to a function applicable to {\tt p}. The reason that a conversion is necessary is because algebra homomorphism contains more information than a function, it is a structure containing the map and other fields containing (proofs of) properties of algebra homomorphism.
However in polynomial library of {\tt mathlib}, the definition of root is as following :

\begin{minted}[mathescape,linenos,numbersep=5pt,frame=single,framesep=2mm,breaklines,escapeinside=||]{Lean}
def is_root (p : polynomial R) (a : R) : Prop := p.eval a = 0
\end{minted}

Thus the first part of this formalisation is to unify the two evaluation methods -- denote $i$ to be the trivial embedding $\mathbb Z[X]\subseteq\mathbb R[X]$ and $\iota_x$ to be the unique $\mathbb Z$-algebra homomorphism $\iota_x : \mathbb Z[X]\to\mathbb R$ given by $X\to x$ then for all polynomial $p(X)\in\mathbb Z[X]$, then $\forall x\in\mathbb R,(i p)(x) = \iota_x p$:

\begin{code}
\begin{minted}[mathescape,linenos,numbersep=5pt,frame=single,framesep=2mm,breaklines,escapeinside=||]{Lean}
-- the trivial embedding $\mathbb{Z}[X]\subseteq\mathbb{R}[X]$
def poly_int_to_poly_real (p : ℤ[X]) : polynomial ℝ := polynomial.map ℤembℝ p
    
def poly_int_to_poly_real_wd (p : ℤ[X]) := 
  ∀ x : ℝ, polynomial.aeval ℤ ℝ x p = (poly_int_to_poly_real p).eval x
    
theorem poly_int_to_poly_real_well_defined |\label{codethm:countableUnify}|
  (x : ℝ) (p : ℤ[X]) : poly_int_to_poly_real_wd p :=
begin
  proof_omitted
end
\end{minted}
\caption{unifying two ways of evaluation}
\label{code:countableUnify}
\end{code}

For any $p\in\mathbb Z[X]$, we can define the set of roots to be $\{x \in\mathbb R | (i p)(x) = 0\}$ or $\{x\in\mathbb R| \iota_x p=0\}$ where the former is builtin as {\tt $\uparrow$(poly\_int\_to\_poly\_real p).roots}\footnote{{\tt \_.roots} in fact has type {\tt finset ℝ}. The type {\tt finset} is a {\tt set} with a proof of finite cardinality. Here $\uparrow$ is used to convert a {\tt finset} to {\tt set} by discarding the proof of finite cardinality.} and the latter is defined as line \ref{code:rootsDef} in source code \ref{lst:rootsDef}. By line \ref{codethm:countableUnify} in source code \ref{code:countableUnify}, two sets must be equal, then two sets are have finite cardinality:

\begin{code}
\begin{minted}[mathescape,linenos,numbersep=5pt,frame=single,framesep=2mm,breaklines, escapeinside=§§]{Lean}
def roots_real (p : ℤ[X]) : set ℝ := §\label{code:rootsDef}§
  {x | polynomial.aeval ℤ ℝ x p}

theorem roots_real_eq_roots (p : ℤ[X]) (hp : p ≠ 0) : 
  roots_real p = §$\uparrow$§(poly_int_to_poly_real p).roots :=
begin
  proof_omitted
end

theorem roots_finite (p : ℤ[X]) (hp : p ≠ 0) : 
  set.finite (roots_real p) :=
begin
  proof_omitted
end
\end{minted}
\caption{two ways of defining roots}
\label{lst:rootsDef}
\end{code}

We defined the set of all algebraic numbers over $\mathbb Z$ to be
\begin{minted}[mathescape,linenos,numbersep=5pt,frame=single,framesep=2mm,breaklines, escapeinside=§§]{Lean}
def algebraic_set : set ℝ := {x | is_algebraic ℤ x}
\end{minted}
To investigate the countability of {\tt algebraic\_set}, we compare it with
\begin{equation}
  \bigcup_{n\in\mathbb N}\bigcup_{\substack{p\in\mathbb{Z}[X]\\ p\ne 0\\ \deg{p}<n+1}} \{x\in\mathbb{R}|\iota_xp=0\}.
  \label{countability:setEq}
\end{equation}


To this end, we introduce some types of interest:
\begin{minted}[mathescape,linenos,numbersep=5pt,frame=single,framesep=2mm,breaklines, escapeinside=§§]{Lean}
notation `int_n` n := fin n -> ℤ
notation `nat_n` n := fin n -> ℕ
notation `poly_n'` n := {p : ℤ[X] // p ≠ 0 ∧ p.nat_degree < n}
notation `int_n'` n := {f : fin n -> ℤ // f ≠ 0}
notation `int'` := {r : ℤ // r ≠ 0}
\end{minted}

where  $\langle m, hm\rangle$ is an element of {\tt fin n} if and only if $m$ is a natural number and $hm$ is a proof of $m < n$. Then {\tt fin n} is the type of only $n$ elements. Thus
\begin{itemize}
  \item {\tt int\_n n} is $\mathbb Z^n$;
  \item {\tt int\_n' n} is $\mathbb Z^n-\{(0,\dots,0)\}$;
  \item {\tt int'} is $\mathbb Z-\{0\}$;
  \item {\tt nat\_n n} is $\mathbb N^n$;
  \item {\tt poly\_n' n} is the type of non-zero integer polynomials with degree less than $n$.
\end{itemize}

Then $\mathbb Z\simeq \mathbb Z-\{0\}$ by the bijective function $s:\mathbb Z\to \mathbb Z-\{0\}$:
\begin{equation*}
n\mapsto\left\{
\begin{aligned}
& m & \text{if }m < 0\\
& m + 1 & \text{if }m \ge 0
\end{aligned}
\right.
\end{equation*}
\begin{code}
\begin{minted}[mathescape,linenos,numbersep=5pt,frame=single,framesep=2mm,breaklines, escapeinside=§§]{Lean}
def strange_fun : ℤ -> int' := 
  λ m, if h : m < 0 
       then ⟨m, by linarith⟩ 
       else ⟨m + 1, by linarith⟩

theorem strange_fun_inj : 
  function.injective strange_fun :=
begin
  proof_omitted
end

theorem strange_fun_sur : 
  function.surjective strange_fun :=
begin
  proof_omitted
end

theorem int_eqiv_int' : ℤ §$\simeq$§ int' :=
begin
  apply equiv.of_bijective strange_fun,
  split,
  exact strange_fun_inj,
  exact strange_fun_sur,
end
\end{minted}
\caption{$\mathbb Z\simeq \mathbb Z-\{0\}$}
\end{code}

Then we prove that for all non-zero $n:\mathbb N$, non-zero integer polynomials of degree less than $n$ bijectively correspond to $\mathbb Z^n-\{(0,\dots,0)\}$ via the function:
$p\mapsto \mathbf{z}$ where the $i$-th coordinate of $\mathbf{z}$ is the $i$-th coefficient of $p$.
\begin{code}
\begin{minted}[mathescape,linenos,numbersep=5pt,frame=single,framesep=2mm,breaklines, escapeinside=§§]{Lean}
def identify (n : nat) : (poly_n' n) -> (int_n' n) := 
  λ p, ⟨λ m, p.1.coeff m.1, a_proof_§$\mathbf{z}$§_is_not_zero⟩

theorem sur_identify_n (n : nat) (hn : n ≠ 0) : 
    function.surjective (identify n) :=
begin
  proof_omitted
end

theorem inj_identify_n (n : nat) (hn : n ≠ 0) : 
  function.injective (identify n) :=
begin
  proof_omitted
end

theorem poly_n'_equiv_int_n' (n : nat) : 
  (poly_n' n.succ) §$\simeq$§ (int_n' n.succ) :=
begin
  apply equiv.of_bijective (identify n.succ),
  split,
  exact inj_identify_n n.succ (nat.succ_ne_zero n),
  exact sur_identify_n n.succ (nat.succ_ne_zero n),
end
\end{minted}
\caption{non-zero integer polynomial with degree less than $n$ has the same cardinality as $\mathbb Z^n-\{(0,\dots,0)\}$, here {\tt n.succ} means $n+1$.}
\end{code}

Then we define two injective functions $F : \mathbb{Z}^{n+1}\to\mathbb{Z}^{n+1}-\{(0,\dots,0)\}$ and $G : \mathbb{Z}^{n+1}-\{(0,\dots,0)\}\to\mathbb{Z}^{n+1}$ by:
\begin{equation*}
\begin{aligned}
F (m_0,\dots,m_n) &= (s(m_0),\dots,s(m_n)) \\
G (m_0,\dots,m_n) &= (m_0,\dots,m_n)
\end{aligned}
\end{equation*}
where $s:\mathbb Z\to \mathbb Z-\{0\}$ is defined previously. By Schröder-Berstein theorem, there is then a bijection $\mathbb{Z}^{n+1}\to\mathbb{Z}^{n+1}-\{(0,\dots,0)\}$ and thus $\mathbb{Z}^{n+1}\simeq\mathbb{Z}^{n+1}-\{(0,\dots,0)\}$:
\begin{code}
\begin{minted}[mathescape,linenos,numbersep=5pt,frame=single,framesep=2mm,breaklines, escapeinside=§§]{Lean}
def F (n : nat) : (int_n n.succ) -> (int_n' n.succ) := 
  λ f, ⟨λ m, (strange_fun (f m)).1,
    a_proof_of_§$(s(m_0),\dots,s(m_n))$§_non-zero⟩
theorem F_inj (n : nat) : function.injective (F n) :=
begin
  proof_omitted
end

def G (n : nat) : (int_n' n.succ) -> (int_n n.succ) := 
  λ f m, (f.1 m)
theorem G_inj (n : nat) : function.injective (G n) :=
begin
  proof_omitted
end

theorem int_n_equiv_int_n' (n : nat) : 
  (int_n n.succ) §$\simeq$§ int_n' n.succ :=
begin
  choose B HB using function.embedding.schroeder_bernstein (F_inj n) (G_inj n),
  apply equiv.of_bijective B HB,
end
\end{minted}
\caption{$\mathbb{Z}^{n+1}\simeq\mathbb{Z}^{n+1}-\{(0,\dots,0)\}$}
\end{code}

For any natural number $n\ge 1$, we then construct two injective function $f_n : \mathbb{Z}^{n+2}\to\mathbb{Z}^{n+1}\times\mathbb{Z}$ and $g_n:\mathbb{Z}^{n+1}\times\mathbb{Z}\to\mathbb{Z}^{n+2}$:
\begin{equation*}
\begin{aligned}
f_n((m_0,\dots,m_{n+1}))&=((m_0,\dots,m_{n}),m_{n+1})\\
g_n(((m_0,\dots,m_{n}), m_{n+1}))&=(m_0,\dots,m_{n+1})
\end{aligned}
\end{equation*}
Then by Schr\"oder-Berstein theorem $\mathbb{Z}^{n+2}\simeq\mathbb{Z}^{n+1}\times\mathbb{Z}$ for all $n\ge 1$.
\begin{code}
\begin{minted}[mathescape,linenos,numbersep=5pt,frame=single,framesep=2mm,breaklines, escapeinside=§§]{Lean}
def fn (n : nat) : 
  (int_n n.succ.succ) -> (int_n n.succ) × ℤ :=  λ r,
  ⟨λ m, r (⟨m.1, nat.lt_trans m.2 (nat.lt_succ_self n.succ)⟩), 
   r (⟨n.succ, nat.lt_succ_self n.succ⟩)⟩
theorem fn_inj (n : ℕ) : function.injective (fn n) :=
begin
  proof_omitted
end

def gn (n : nat) : (int_n n.succ) × ℤ -> (int_n n.succ.succ) := λ r m,
begin
  by_cases (m.1 = n.succ),
    exact r.2,
    exact r.1 (⟨m.1, lt_of_le_of_ne (fin.le_last m) h⟩),
end
theorem gn_inj (n : nat) : function.injective (gn n) :=
begin
  proof_omitted
end
  
theorem aux_int_n (n : nat) :
  (int_n n.succ.succ) §$\simeq$§ (int_n n.succ) × ℤ :=
begin
choose B HB using function.embedding.schroeder_bernstein (fn_inj n) (gn_inj n),
apply equiv.of_bijective B HB,
end
\end{minted}
\caption{$\mathbb{Z}^{n+2}\simeq\mathbb{Z}^{n+1}\times\mathbb{Z}$ for all $n\ge 1$}
\end{code}

Now we are finally in the position of using formula \ref{countability:setEq} to prove the countability of all algebraic numbers. We first define the set of real roots of non-zero integer polynomial of degree less than $n$ to be:
\begin{minted}[mathescape,linenos,numbersep=5pt,frame=single,framesep=2mm,breaklines, escapeinside=§§]{Lean}
def algebraic_set'_n (n : ℕ) : set ℝ := 
  §$\bigcup$§ p : (poly_n' n.succ), roots_real p.1
\end{minted}
Hence by taking union over all natural numbers we can obtain an equivalent definition of all algebraic number over $\mathbb{Z}$:
\begin{minted}[mathescape,linenos,numbersep=5pt,frame=single,framesep=2mm,breaklines, escapeinside=§§]{Lean}
def algebraic_set' : set real := 
  §$\bigcup$§ n : ℕ, algebraic_set'_n n.succ

theorem algebraic_set'_eq_algebraic_set : 
  algebraic_set' = algebraic_set :=
begin
  proof_omitted
end
\end{minted}
We prove by induction that for any $n\in\mathbb N$, $\mathbb{Z}^{n+1}$ is denumerable (i.e. countably infinite) where the base case is $\mathbb Z^1\simeq Z$ and the inductive step is to prove $\mathbb{Z}^{n+2}$ is denumerable using denumerability of $\mathbb{Z}^{n+1}$. Since non-zero integer polynomials of degree less than $n+1$ bijectively corresponds to $\mathbb{Z}^{n+1}$, we have non-zero integer polynomials of degree less than $n+1$ is denumerable hence is countable. Then the result of taking union over the countable set $\mathbb N$, the result $ \bigcup_{n\in\mathbb N}\bigcup_{p\in\mathbb{Z}[X], p\ne 0, \deg{p}<n+1} \{x\in\mathbb{R}|\iota_xp=0\}$ is still countable. Then finally the set of all algebraic numbers over $\mathbb Z$ is countable. Since $\mathbb R$ is uncountable, transcendental number must exist:
\begin{code}
\begin{minted}[mathescape,linenos,numbersep=5pt,frame=single,framesep=2mm,breaklines, escapeinside=§§]{Lean}
theorem int_1_equiv_int : (int_n 1) §$\simeq$§ ℤ := 
begin
  proof_omitted
end

theorem int_n_denumerable {n : nat} :
  denumerable (int_n n.succ) :=
begin
  proof_omitted
end

theorem poly_n'_denumerable (n : nat) : 
  denumerable (poly_n' n.succ) :=
begin
  proof_omitted
end

theorem algebraic_set'_n_countable (n : nat) :
  set.countable (algebraic_set'_n n) :=
begin
  proof_omitted
end

theorem algebraic_set'_countable : 
  set.countable algebraic_set' :=
  set.countable_Union 
    (λ n, algebraic_set'_n_countable n.succ)

theorem algebraic_set_countable : 
  set.countable algebraic_set :=
begin
  rw <-algebraic_set'_eq_algebraic_set, 
  exact algebraic_set'_countable
end

theorem transcendental_number_exists : 
  ∃ x : ℝ, transcendental x :=
begin
  proof_omitted
end
\end{minted}
\caption{algebraic numbers are countable, hence transcendental numbers exists}
\end{code}


\section{Liouville's theorem and Liouville number}\label{fmlsn:li}
\subsection*{General theory about Liouville number}
\addcontentsline{toc}{subsection}{General theory about Liouville number}
A Liouville number is a real number that is ``almost rational'', i.e. for any $n\in\mathbb N$ there is a rational number\footnote{Without lose of generality, we are always assuming the denominator is a strictly positive natural number.} $\frac ab\in\mathbb Q$ such that $b > 1$ and $0<|x-\frac ab|<\frac1{b^n}$.
\begin{code}
\begin{minted}[mathescape,linenos,numbersep=5pt,frame=single,framesep=2mm,breaklines, escapeinside=§§]{Lean}
def liouville_number (x : ℝ) := 
  ∀ n : ℕ, ∃ a b : ℤ,  
    b > 1 ∧ 
    0 < abs(x - a / b) ∧ abs(x - a / b) < 1/b^n
\end{minted}
\caption{Definition of Liouville number}
\end{code}

We first prove a lemma about irrational root of an integer polynomial:
\begin{lemma}\label{lemma:irrationalRoot}
if $f$ is an integer polynomial with degree $m>1$ and $\alpha$ is an irrational root for $i(f)$ where $i:\mathbb Z[X]\to\mathbb R[X]$ is the trivial embedding, then there is a postive real number $A$ such that for every rational number $\frac ab$, $\left|\alpha-\frac ab\right|>\frac A {b^m}$:  

\begin{minted}[mathescape,linenos,numbersep=5pt,breaklines, escapeinside=§§,frame=single,framesep=2mm]{Lean}
lemma about_irrational_root (α : ℝ)
  (hα : irrational α) (f : ℤ[X]) 
  (f_deg : f.nat_degree > 1)
  (α_root : f_eval_on_ℝ f α = 0) :
  ∃ A : ℝ, A > 0 ∧ ∀ a b : ℤ, b > 0 -> abs(α - a/b) > (A/b^(f.nat_degree)) :=
\end{minted}
\end{lemma}

\begin{proof}
We will abuse the notation to denote $f$ as $i(f)\in\mathbb{R}[X]$
\begin{minted}[mathescape,linenos,numbersep=5pt,breaklines, escapeinside=§§,firstnumber=last,frame=single,framesep=2mm]{Lean}
begin
  have f_nonzero : f ≠ 0,
    proof_omitted
  generalize hfℝ: f.map ℤembℝ = f_ℝ,
  have hfℝ_nonzero : f_ℝ ≠ 0,
    proof_omitted
  generalize hDf: f_ℝ.derivative = Df_ℝ,
\end{minted}

Since $\mathrm{abs}\circ Df : \mathbb R\to\mathbb R$ given by $x\mapsto \left|\left.\frac{\mathrm d}{\mathrm d t}\right|_{t=x}f(t)\right|$ is a continuous function and $[\alpha-1,\alpha+1]$ is a non-empty compact subset of $\mathbb R$, $\mathrm{abs} \circ Df$ attains a maximum on $[\alpha-1,\alpha+1]$ denote it by $M$.

\begin{minted}[mathescape,linenos,numbersep=5pt,breaklines, escapeinside=§§,firstnumber=last,frame=single,framesep=2mm]{Lean}
  have H := is_compact.exists_forall_ge 
              a_proof_of_§$[\alpha-1,\alpha+1]$§_compact
              a_proof_of_§$[\alpha-1,\alpha+1]$§_not_empty
              a_proof_of_§$\mathrm{abs}\circ Df$§_continuous,

  choose x_max hx_max using H,
  generalize M_def: abs (Df_ℝ.eval x_max) = M,
  have hM := hx_max.2, rw M_def at hM,
  have M_non_zero : M ≠ 0,
    proof_omitted
  have M_pos : M > 0,
    proof_omitted
\end{minted}

Let use consider the smallest element $B$ of the set $\{1, \frac 1 M\}\cup\{\left|\alpha-x\right|| f(x)=0 \land x\ne\alpha\}$, then $B>0$.
\begin{minted}[mathescape,linenos,numbersep=5pt,breaklines, escapeinside=§§,firstnumber=last,frame=single,framesep=2mm]{Lean}
  generalize roots_def :  f_ℝ.roots = f_roots,
  generalize roots'_def : f_roots.erase α = f_roots',
  generalize roots_distance_to_α : f_roots'.image (λ x, abs (α - x)) = distances,
  generalize hdistances' : insert (1/M) (insert (1:ℝ) distances) = distances',
  have hnon_empty: distances'.nonempty, 
    proof_omitted
  generalize hB : finset.min' distances' hnon_empty = B,
  have allpos : ∀ x : ℝ, x §$\in$§ distances' -> x > 0,
    proof_omitted
  have B_pos : B > 0,
    proof_omitted
\end{minted}

Let $A=\frac B 2$ then $A > B > 0$. We claim that $A$ satisfies the lemma, i.e. $A>0$ and for every rational number $\frac ab$, $\left|\alpha-a/b\right|>\frac A{b^m}$ where $m$ is the degree of $f$.

\begin{minted}[mathescape,linenos,numbersep=5pt,breaklines, escapeinside=§§,firstnumber=last,frame=single,framesep=2mm]{Lean}
  generalize hA : B / 2 = A,
  use A, split,
  a_proof_of_§$A>0$§
\end{minted}

We proceed by assuming that there exists a rational number $\frac a b$ such that $\left|\alpha-\frac a b\right|\le\frac A{b^m}$ for a contradiction. Since $b\ge 1$, we have $\left|\alpha-\frac ab\right|\le A < B$. Then $\frac a b$ is not root of $f$ because otherwise $B\le \left|\alpha-\frac ab\right|$.

\begin{minted}[mathescape,linenos,numbersep=5pt,breaklines, escapeinside=§§,firstnumber=last,frame=single,framesep=2mm]{Lean}
  by_contra absurd, 
  simp only [gt_iff_lt, classical.not_forall, not_lt, classical.not_imp] at absurd,
  choose a ha using absurd,
  choose b hb using ha,                               
  have hb2 : b ^ f.nat_degree ≥ 1,
    proof_omitted
  have hb21 : abs (α - a / b) ≤ A, 
    proof_omitted
  have hb22 : abs (α - a/b) < B,
    proof_omitted
  have hab0 : (a/b:ℝ) §$\in$§ set.Icc (α-1) (α+1),
    proof_omitted
  have hab1 : (a/b:ℝ) ≠ α,
    proof_omitted
  have hab2 : (a/b:ℝ) §$\notin$§ f_roots,
    proof_omitted
\end{minted}

Since $\alpha\ne \frac a b$, we can assume without lose of generality that $\frac a b < \alpha$. Since $\mathrm{eval}_f:\mathbb R\to \mathbb R$ given by $x\mapsto f(x)$ is differentiable, we can use mean value theorem to find $x_0\in(\frac ab, \alpha)$ such that 
\begin{equation*}
\begin{aligned}
  Df(x_0)&=\frac{\mathrm{eval}_f(\alpha)-\mathrm{eval}_f(\frac ab)}{\alpha-\frac ab} & [\text{Mean value theorem}]\\
         &=-\frac{\mathrm{eval}_f(\frac ab)}{\alpha-\frac ab} & [\alpha\text{ is a root of } i(f)]
\end{aligned}
\end{equation*}

\begin{minted}[mathescape,linenos,numbersep=5pt,breaklines, escapeinside=§§,firstnumber=last,frame=single,framesep=2mm]{Lean}
  have hab3 := ne_iff_lt_or_gt.1 hab1,
  cases hab3,
  have H := 
    exists_deriv_eq_slope (λ x, f_ℝ.eval x) hab3 _ _, 
  choose x0 hx0 using H,
  have hx0r := hx0.2,
  rw [polynomial.deriv, hDf, <-hfℝ] at hx0r,
  rw [f_eval_on_ℝ] at α_root, rw [α_root, hfℝ] at hx0r, simp only [zero_sub] at hx0r,
\end{minted}

Then $|Df(x_0)|>0$ hence $\left|\alpha-\frac ab\right|=\left|\frac{\mathrm{eval}_f(\frac a b)}{Df(x_0)}\right|$ is non-zero. Since $M$ is the maximum of $\mathrm{abs}\circ Df$ on $[\alpha-1,\alpha+1]$. We have $|Df(x_0)|\le M$ and thus $\left|\alpha-\frac ab\right|\ge \frac{|\mathrm{eval}_f(\frac a b)|}{M}$. If we write $f(X)$ as $\sum_{j=0}^m \lambda_j X^j$ then
\begin{equation*}
\left|\mathrm{eval}_f\left(\frac a b\right)\right|=\left|\sum_{j=0}^m\lambda_j \frac{a^j}{b^j}\right|= \frac1{b^m}\left|\sum_{j=0}^m\lambda_j a^jb^{m-j}\right|\ge\frac1{b^m}
\end{equation*}
Hence we have $\left|\alpha-\frac a b\right|\ge \frac1{Mb^m}>\frac{A}{b^m}$. But we assumed $\left|\alpha-\frac ab\right|<\frac A{b^m}$ to start with, this is the desired contradiction.

\begin{minted}[mathescape,linenos,numbersep=5pt,breaklines, escapeinside=§§,firstnumber=last,frame=single,framesep=2mm]{Lean}
  have Df_x0_nonzero : Df_ℝ.eval x0 ≠ 0,
    proof_omitted
  have H2 : abs(α - a/b) = abs((f_ℝ.eval (a/b:ℝ)) / (Df_ℝ.eval x0)),
    proof_omitted

  have ineq' : polynomial.eval (a/b:ℝ) (polynomial.map ℤembℝ f) ≠ 0,
    proof_omitted
  have ineq : abs (α - a/b) ≥ 1/(M*b^(f.nat_degree)),
    proof_omitted
  have ineq2 : 1/(M*b^(f.nat_degree)) > A / (b^f.nat_degree),
    proof_omitted
  have ineq3 : abs (α - a / b) > A / b ^ f.nat_degree,
    proof_omitted
  have ineq4 : abs (α - a / b) > abs (α - a / b),
    proof_omitted 
  linarith,
  
  §\textrm{We omit the proof of differentiability of $\mathrm{ev}_f$, continuity of $\mathrm{abs}\circ Df$ and the case when $\frac{a}{b}>\alpha$}§
  rest_omitted
end
\end{minted}
\end{proof}

We then prove irrationality of Liouville number. 
\begin{lemma}
Every Liouville number is irrational
\begin{minted}[mathescape,linenos,numbersep=5pt,frame=single,framesep=2mm,breaklines, escapeinside=§§]{Lean} 
lemma liouville_numbers_irrational: ∀ (x : ℝ), (liouville_number x) -> irrational x :=
\end{minted}
\end{lemma}

\begin{proof}
Let $x$ be an arbitrary Liouville number and suppose for a contradiction that $x=\frac ab$, write $n=b+1$ then $2^{n-1}>b$.
\begin{minted}[firstnumber=last,mathescape,linenos,numbersep=5pt,frame=single,framesep=2mm,breaklines, escapeinside=§§]{Lean}
begin
  intros x liouville_x a b hb rid, 
  replace rid : x = §$\uparrow$§a / §$\uparrow$§b, linarith,
  generalize hn : b.nat_abs + 1 = n,
  have b_ineq : 2 ^ (n-1) > b,
    proof_omitted
\end{minted}

Since $x=\frac ab$ is a Liouville number we can find a rational number $\frac pq$ such that $q>1$ and $0<\left|\frac ab-\frac pq\right|<\frac1{q^n}$ or equivalently $0<\frac{\left|aq-bp\right|}{bq}<\frac1{q^n}$. If $aq-bp=0$, then $0<0$ is the desired contradiction.

\begin{minted}[mathescape,linenos,numbersep=5pt,frame=single,framesep=2mm,breaklines, escapeinside=§§,firstnumber=last]{Lean} 
  choose p hp using liouville_x n,
  choose q hq using hp, rw rid at hq,
  have q_pos : q > 0 := by linarith, 
  rw [div_sub_div at hq, abs_div at hq],

  by_cases (abs (a*q-b*p:ℝ) = 0),
  intermediate_step_omitted
  linarith,
\end{minted}

If $aq-bp\ne 0$ then $\frac 1{bq}\le\frac{\left|aq-bp\right|}{bq}$. But we also have $b<2^{n-1}$ and $2^{n-1}q\le q^n$ because $q\ge 2$. Hence $bq<q^n$, then $\frac{\left|aq-bp\right|}{bq}>\frac1{q^n}$. This is the desired contradiction.

\begin{minted}[mathescape,linenos,numbersep=5pt,frame=single,framesep=2mm,breaklines, escapeinside=§§,firstnumber=last]{Lean} 
  have ineq4 : 1 / (b * q : ℝ) ≤ (abs(a * q - b * p:ℝ)) / (b * q),
    proof_omitted
  have b_ineq'' : (b*q:ℝ) < (2:ℝ)^(n-1)*(q:ℝ), 
    proof_omitted
  have q_ineq3 : 2 ^ (n - 1) * q ≤ q ^ n,
    proof_omitted
  have b_ineq2 : b * q < q ^ n, linarith,
  have rid'' : 
    abs (a*q-b*p:ℝ) / (b*q:ℝ) > 1/q^n,
    proof_omitted,
  
  have hq22 := hq2.2,
  linarith,

  §\textrm{We manipulated inequalities involving division and multiplication hence we need to prove several things to be positive.}§
  proofs_omitted
end
\end{minted}
\end{proof}

With the above lemmas, we are ready to prove the transcendence of Liouville numbers.
\begin{theorem}
Every Liouville number is transcendental
\begin{minted}[mathescape,linenos,numbersep=5pt,frame=single,framesep=2mm,breaklines, escapeinside=§§]{Lean}
theorem liouville_numbers_transcendental : ∀ x : ℝ, liouville_number x -> transcendental x := 
\end{minted}
\end{theorem}

\begin{proof}
Let $x$ be an arbitrary Liouville number then $x$ is irrational. Assume for a contradiction that $x$ is algebraic, let $f$ be the non-zero integer polynomial admitting $x$ as root as a $\mathbb R$-polynomial. Then since $x$ is irrational, $f$ has degree at least 2.

\begin{minted}[mathescape,linenos,numbersep=5pt,frame=single,framesep=2mm,breaklines, escapeinside=§§,firstnumber=last]{Lean}
begin
  intros x liouville_x,
  have irrational_x : irrational x := liouville_numbers_irrational x liouville_x,
  intros rid, rw is_algebraic at rid,
  choose f hf using rid, 
  have f_deg : f.nat_degree > 1,
    proof_omitted
\end{minted}

By using lemma \ref{lemma:irrationalRoot} we can find a real number $A>0$ such that for any rational number $\frac pq$, $\left|x-\frac pq\right|>\frac A{q^n}$ where $n$ is the degree of $f$.
\begin{minted}[mathescape,linenos,numbersep=5pt,frame=single,framesep=2mm,breaklines, escapeinside=§§,firstnumber=last]{Lean} 
  have about_root : f_eval_on_ℝ f x = 0,
    proof_omitted
  choose A hA using about_irrational_root x irrational_x f f_deg about_root,
  have A_pos := hA.1,
\end{minted}

Since $\mathbb R$ is an Archimedean field, we can find an $r\in\mathbb N$ such that $\frac1A\le2^r$. Then consider $m:=r+n$. Since $x$ is a Liouville number, there is a rational number $\frac a b$ such that $b>1$ and $0<\left|x-\frac a b\right|<\frac1{b^m}=\frac1{b^r b^n}$.
\begin{minted}[mathescape,linenos,numbersep=5pt,frame=single,framesep=2mm,breaklines, escapeinside=§§,firstnumber=last]{Lean} 
  have exists_r := pow_big_enough A A_pos, 
  choose r hr using exists_r,
  have hr' : 1/(2^r) ≤ A,
    proof_omitted
  generalize hm : r + f.nat_degree = m,
  replace liouville_x := liouville_x m,
  choose a ha using liouville_x,
  choose b hb using ha,

  have ineq : abs (x-a/b:ℝ) < 1/((b:ℝ)^r)*(1/(b:ℝ)^f.nat_degree),
    proof_omitted
\end{minted}

Since $b\ge 2$, we have $\frac1{b^r}\le\frac1{2^r}\le A$. Thus $\left|x-\frac a b\right|<\frac1{b^r b^n}\le \frac A{b^n}$. This contradicts lemma \ref{lemma:irrationalRoot} stating that $\left|x-\frac a b\right|>\frac{A}{q^n}$.
\begin{minted}[mathescape,linenos,numbersep=5pt,frame=single,framesep=2mm,breaklines, escapeinside=§§,firstnumber=last]{Lean} 
  have ineq3 : 1/(b:ℝ)^r ≤ A,
    proof_omitted,
  have ineq4 : 1 /(b:ℝ)^r * (1/(b:ℝ)^ f.nat_degree) ≤ (A / (b:ℝ)^f.nat_degree),
    proof_omitted
  have ineq5 :  abs (x - a/b:ℝ) < A/(b:ℝ)^f.nat_degree, linarith,
  have rid := hA.2 a b _, linarith, linarith,
end
\end{minted}
\end{proof}

\subsection*{Construction of a Liouville number}
\addcontentsline{toc}{subsection}{Construction of a Liouville number}

Knowing that all Liouville numbers are transcendental, we now focus on constructing a Liouville number $$\alpha=\sum_{j=0}^\infty \frac1{10^{j!}}$$hence obtain a concrete example of transcendental number $\alpha$.

\begin{lemma}
$\alpha$ converges.
\end{lemma}

\begin{proof}
Since for any $n\in\mathbb N$ we have $\frac 1{10^{n}}$ is none-negative and $\frac1{10^n}\le\frac1{10^{n!}}$, we can use comparison test against $\sum_{j=0}^\infty\frac1{10^j}$ to deduce the convergence of $\alpha$.

\begin{minted}[mathescape,linenos,numbersep=5pt,frame=single,framesep=2mm,breaklines, escapeinside=§§]{Lean}
def ten_pow_n_fact_inverse (n : ℕ) : ℝ := 
  (1/10)^n.fact
def ten_pow_n_inverse (n : ℕ) : ℝ := 
  (1/10)^n

lemma summable_ten_pow_n_fact_inverse : summable ten_pow_n_fact_inverse :=
begin
  exact @summable_of_nonneg_of_le _ 
    ten_pow_n_inverse 
    ten_pow_n_fact_inverse 
    a_proof_of_§$\frac{1}{10^{n}}\ge0$§
    a_proof_of_§$\frac{1}{10^n}\le\frac{1}{10^{n!}}$§
    a_proof_of_§$\sum_{j=0}^\infty\frac{1}{10^n}$§_converges,
end

def α := §$\sum'$§ n, ten_pow_n_fact_inverse n
\end{minted}
\end{proof}

\begin{lemma}
  % theorem α_k_rat (k:ℕ) : ∃ (p : ℕ), α_k k = (p:ℝ) / ((10:ℝ) ^ k.fact) :=
  % begin
\end{lemma}

\begin{theorem}
$\alpha$ is a Liouville number
\begin{minted}[mathescape,linenos,numbersep=5pt,frame=single,framesep=2mm,breaklines, escapeinside=§§]{Lean}
theorem liouville_α : liouville_number α :=
\end{minted}
\end{theorem}
\begin{proof}
We need to prove that for an arbitrary $n\in\mathbb N$, there exists a rational number $\frac{p(n)}{q(n)}$ such that $p(n)>1$ and $0 < \left|\alpha-\frac{p(n)}{q(n)}\right|<\frac{1}{q(n)^n}$
\end{proof}

\section{Hermite's proof of transcendence of $e$}\label{fmlsn:e}

% \chapter{Further Work}
% An immediate next step would be formalising the transcendence of $\pi$.

% \chapter*{Reflection}
% \addcontentsline{toc}{chapter}{Reflection}

%\bibliographystyle{alphanat}
% \chapter{Glossary of definitions and theorems}


\nocite{*}
\printbibliography[heading=bibintoc]

% \inputminted[breaklines]{lean}{../small_things.lean}
% \inputminted[breaklines]{lean}{../algebraic_countable_over_Z.lean}
% \inputminted[breaklines]{lean}{../liouville_theorem.lean}
% \inputminted[breaklines]{lean}{../e_trans_helpers2.lean}
% \inputminted[breaklines]{lean}{../e_transcendental.lean}
\end{document}
